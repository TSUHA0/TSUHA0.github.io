[{"categories":["OS"],"content":"TsuhaOS-00 汇编杂谈 rax,eax,ax,ah,al 关系 |63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............| |RAX...................| 8086 寄存器 寄存器 描述 AX 累加数据结果 BX 数据段数据指针 CX 字符串和循环计数器 DX I/O 指针 SI 源数据指针 DI 目的数据指针 SP 栈指针 BP 栈数据指针 CS 代码段寄存器 DS 数据段寄存器 SS 栈段寄存器 ES 额外的寄存器 IP cs：ip 下一条指令地址 % 表示通配符， %.bin: %.asm nasm %\u003c -o %@ 汇编函数调用==== jmp short start 占用两个字节，jmp指令一个字节，地址一个字节，-128 - 127 jmp near start 占用三个字节，jmp指令一个字节，地址两个字节，-32768 - 32767 jmp far ; far function call 0:print_far ; push cs, push ip, jmp far print_far: ;使用retf返回 retf ; pop ip, pop cs ; 与上面的不同 call print print: ret ; pop ip 内中断 0x000 ~ 0x3ff 的 1kb 为中断向量表，一个向量由 cs:ip 组成，共 32 位 4B，因此最多存 256 个中断向量。 例如要向第 0x80 中断向量注册 print 函数，可以使用如下代码，注意需要用 iret 返回，以为多向栈压入了 flags 。 mov word [0x80 * 4], print mov word [0x80 * 4 + 2], 0 int 0x80 print: ; todo iret; pop ip, pop cs, pop flags ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-000-%E6%B1%87%E7%BC%96%E6%9D%82%E8%B0%88/:0:0","tags":["OS","操作系统"],"title":"TsuhaOS-000-汇编杂谈","uri":"/posts/tsuhaos/tsuhaos-000-%E6%B1%87%E7%BC%96%E6%9D%82%E8%B0%88/"},{"categories":["OS"],"content":"TsuhaOS-01 配置环境 ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:0:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["OS"],"content":"1. 安装软件包 nasm bochs 2.7 ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:1:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["OS"],"content":"2. 在屏幕上打印一个字符 bochsrc 文件，用于配置 boch 启动参数： display_library: x, options=\"gui_debug\" 开启图形化 debug。 boot: disk 硬盘启动。 ata0-master: type=disk, path=\"master.img\", mode=flat 指定 master.img 文件。 # bochsrc 文件 # configuration file generated by Bochs plugin_ctrl: unmapped=true, biosdev=true, speaker=true, extfpuirq=true, parallel=true, serial=true, iodebug=true config_interface: textconfig display_library: x, options=\"gui_debug\" memory: host=32, guest=32 romimage: file=\"/usr/local/share/bochs/BIOS-bochs-latest\", address=0x00000000, options=none vgaromimage: file=\"/usr/local/share/bochs/VGABIOS-lgpl-latest\" boot: disk floppy_bootsig_check: disabled=0 floppya: type=1_44 # no floppyb ata0: enabled=true, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 ata0-master: type=disk, path=\"master.img\", mode=flat ata0-slave: type=none ata1: enabled=true, ioaddr1=0x170, ioaddr2=0x370, irq=15 ata1-master: type=none ata1-slave: type=none ata2: enabled=false ata3: enabled=false optromimage1: file=none optromimage2: file=none optromimage3: file=none optromimage4: file=none optramimage1: file=none optramimage2: file=none optramimage3: file=none optramimage4: file=none pci: enabled=1, chipset=i440fx, slot1=none, slot2=none, slot3=none, slot4=none, slot5=none vga: extension=vbe, update_freq=5, realtime=1, ddc=builtin cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0 cpuid: level=6, stepping=3, model=3, family=6, vendor_string=\"GenuineIntel\", brand_string=\" Intel(R) Pentium(R) 4 CPU \" cpuid: mmx=true, apic=xapic, simd=sse2, sse4a=false, misaligned_sse=false, sep=true cpuid: movbe=false, adx=false, aes=false, sha=false, xsave=false, xsaveopt=false, smep=false cpuid: smap=false, mwait=true print_timestamps: enabled=0 debugger_log: - magic_break: enabled=0 port_e9_hack: enabled=0 private_colormap: enabled=0 clock: sync=none, time0=local, rtc_sync=0 # no cmosimage log: - logprefix: %t%e%d debug: action=ignore info: action=report error: action=report panic: action=ask keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none mouse: type=ps2, enabled=false, toggle=ctrl+mbutton speaker: enabled=true, mode=system parport1: enabled=true, file=none parport2: enabled=false com1: enabled=true, mode=null com2: enabled=false com3: enabled=false com4: enabled=false makefile： #makefile %.bin:%.asm nasm $\u003c -o $@ master.img:boot.bin yes | bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat master.img dd if=boot.bin of=master.img bs=512 count=1 conv=notrunc .PHONY:bochs bochs:master.img bochs -q .PHONY:clean clean: rm -rf *.bin rm -rf *.img boot.asm 内容如下，使用 nasm boot.asm -o boot.bin 编译为 boot.bin，写入 master.img。 ; 代码在内存中的位置为 0x7c00 [org 0x7c00] ; 设置屏幕模式为文本模式，清除屏幕 mov ax,3 int 0x10 ; 初始化段寄存器 mov ax, 0 mov ds, ax mov es, ax mov ss, ax mov sp, 0x7c00 ;程序指针 ; 0xb8000 文本显示的内存区域，从这里开始显示文本 mov ax, 0xb800 mov ds, ax mov byte [0], 'H' ; 阻塞 jmp $ ; 0 填充剩余区域 times 510 - ($ - $$) db 0 ; 主引导扇区的最后两个字节必须是 0xaa55, ; dw 0xaa 0x55 ; 由于是小端存储，所以要先写 0x55 db 0x55, 0xaa 实模式 print 则使用以下代码： ah 使用 0x0e， al 输入具体字符， 调用 int 0x10 输出， 这里的 int 指的是 interrupt 中断。 mov si, booting call print print: mov ah, 0x0e .next: mov al, [si] cmp al, 0 jz .done int 0x10 inc si jmp .next .done: ret booting: ; \\n\\r db \"TsuhaOS booting...\", 10, 13, 0 另外可以直接在 0xb8000 区域写入字节来实现打印，但是这种方法不好打印换行回车 tprint: mov ax, 0xb800 mov es, ax .next: mov al, [si] cmp al, 0 mov ah, 0b0000_1110 ; ah 可以控制字体样式 jz .done mov bx, [video] mov [es:bx], ax add word [video], 2 inc si jmp .next .done: ret video: dw 0x0 msg: db \"TsuhaOS booting...\", 0 ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:2:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["OS"],"content":"3. 读取硬盘 mov edi, 0x1000 ; 读取的目标内存 mov ecx, 2 ; 起始扇区 mov bl, 4 ; 扇区数量 call read_disk read_disk: ; 设置读写扇区的数量 mov dx, 0x1f2 mov al, bl out dx, al inc dx ; 0x1f3 mov al, cl ; 起始扇区低8位 out dx, al inc dx ; 0x1f4 shr ecx, 8 mov al, cl ; 起始扇区中8位 out dx, al inc dx ; 0x1f5 shr ecx, 8 mov al, cl ; 起始扇区高8位 out dx, al inc dx ; 0x1f6 shr ecx, 8 and cl, 0b1111 ;高四位变为0， 只剩下低四位 mov al, 0b1110_0000; or al, cl out dx, al inc dx ;0x1f7 mov al, 0x20 ; 读硬盘 out dx, al xor ecx, ecx ; 清空 ecx mov cl, bl ; 得到读写扇区数量 .read: push cx call .waits call .reads pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2 ; 直接跳转到下一行，nop 消耗时钟周期 jmp $+2 ; 一点点延迟，硬盘要求 jmp $+2 and al, 0b1000_1000 cmp al, 0b0000_1000 jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256 ; 一个扇区 256 字 .readw: in ax, dx jmp $+2 ; 直接跳转到下一行，nop 消耗时钟周期 jmp $+2 ; 一点点延迟，硬盘要求 jmp $+2 mov [edi], ax add edi, 2 loop .readw ret ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:3:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["OS"],"content":"4. 内核加载器 内核加载器： 写内核加载器 loader 将 loader 写入硬盘 在主引导扇区读入 检测正确性 跳转到 loader 执行 实模式的内存布局： 起始地址 结束地址 大小 用途 0x000 0x3FF 1KB 中断向量表 0x400 0x4FF 256B BIOS 数据区 0x500 0x7BFF 29.75 KB 可用区域 0x7C00 0x7DFF 512B MBR 加载区域 0x7E00 0x9FBFF 607.6KB 可用区域 0x9FC00 0x9FFFF 1KB 扩展 BIOS 数据区 0xA0000 0xAFFFF 64KB 用于彩色显示适配器 0xB0000 0xB7FFF 32KB 用于黑白显示适配器 0xB8000 0xBFFFF 32KB 用于文本显示适配器 0xC0000 0xC7FFF 32KB 显示适配器 BIOS 0xC8000 0xEFFFF 160KB 映射内存 0xF0000 0xFFFEF 64KB-16B 系统 BIOS 0xFFFF0 0xFFFFF 16B 系统 BIOS 入口地址 ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:4:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["OS"],"content":"5.内存检测 操作系统不知道要运行在什么机器上，为了兼容机器，需要对内存区域进行检测，判别哪些区域可用。 BIOS 系统调用为0x15 Address Range Descriptor Structure ARDS 字节偏移量 属性名称 描述 0 BaseAddrLow 基地址的低 32 位 4 BaseAddrHigh 基地址的高 32 位 8 LengthLow 内存长度的低 32 位，以字节为单位 12 LengthHigh 内存长度的高 32 位，以字节为单位 16 Type 本段内存的类型 Type 字段 Type 值 名称 描述 1 AddressRangeMemory 这段内存可以被操作系统使用 2 AddressRangeReserved 内存使用中或者被系统保留，操作系统不可以用此内存 其他 未定义 未定义，将来会用到．目前保留． 但是需要操作系统一样将其视为ARR(AddressRangeReserved) 调用前输入 寄存器或状态位 参数用途 EAX 子功能号： EAX 寄存器用来指定子功能号，此处输入为 0xE820 EBX 内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉 BIOS 该返回哪个 ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现，每次中断返回后，BIOS 会更新此值 ES: DI ARDS 缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以 ARDS 格式返回 ECX ARDS 结构的字节大小：用来指示 BIOS 写入的字节数。调用者和 BIOS 都同时支持的大小是 20 字节，将来也许会扩展此结构 EDX 固定为签名标记 0x534d4150，此十六进制数字是字符串 SMAP 的ASCII 码： BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息 返回值 寄存器或状态位 参数用途 CF 位 若CF 位为 0 表示调用未出错，CF 为1，表示调用出错 EAX 字符串 SMAP 的 ASCII 码 0x534d4150 ES:DI ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被BIOS 填充了内存信息 ECX BIOS 写入到 ES:DI 所指向的 ARDS 结构中的字节数，BIOS 最小写入 20 字节 EBX 后续值：下一个 ARDS 的位置。每次中断返回后，BIOS 会更新此值， BIOS 通过此值可以找到下一个待返回的 ARDS 结构，咱们不需要改变 EBX 的值，下一次中断调用时还会用到它。在 CF 位为 0 的情况下，若返回后的 EBX 值为 0，表示这是最后一个 ARDS 结构 ","date":"2023-03-14","objectID":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:5:0","tags":["OS","操作系统"],"title":"TsuhaOS-001-配置环境","uri":"/posts/tsuhaos/tsuhaos-001-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"categories":["语法"],"content":"1. const 指针 int main() { int a = 1; const int ic = 1; int *p1 = \u0026a; int *const p2 = \u0026a; const int *const p3 = \u0026a; const int *p4 = \u0026a; // p1 = p3; // 普通指针不能指向常量, invalid conversion from ‘const int*’ to ‘int*’ // p1 = \u0026ic;// 普通指针不能指向常量 // p3 = \u0026ic; // 常量指针不能被重新赋值 // p2 = p1; // 常量指针不能被重新赋值 p1 = p2; // ok p4 = \u0026ic;// ok p4 = p1; // ok const int \u0026r = a; return 0; } ","date":"2022-12-27","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0/cppprimer%E5%AD%A6%E4%B9%A0/cppprimer%E5%AD%A6%E4%B9%A001/:1:0","tags":["cpp","语法"],"title":"CppPrimer学习01","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0/cppprimer%E5%AD%A6%E4%B9%A0/cppprimer%E5%AD%A6%E4%B9%A001/"},{"categories":["算法"],"content":"ACWING算法学习记录 题目 次数 知识点 状态(1-10) 785.快速排序 2 排序 1 786.第k个数 2 查找 2 912. 排序数组 - 力扣（Leetcode） 归并 2 排序 2 剑指 Offer 51. 数组中的逆序对 - 力扣（Leetcode） 归并 2 排序 1 797. 差分 - AcWing题库 1 差分 1 3. 无重复字符的最长子串 - 力扣（Leetcode） 1 双指针 1 1455. 招聘 - AcWing题库 1 约瑟夫环，DP 1 ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:0:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":["算法"],"content":"1. 快速排序 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5 + 10; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; // 边界条件，注意！！ int x = q[l + r \u003e\u003e 1], i = l - 1, j = r + 1; while (i \u003c j) { while(q[++i] \u003c x); while(q[--j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; ++i) cin \u003e\u003e q[i]; quick_sort(q, 0, n - 1); for (int i = 0; i \u003c n; ++i) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:1:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":["算法"],"content":"2. 排序数组 - 力扣（Leetcode） 归并 class Solution { public: vector\u003cint\u003e tmp; void merge_sort(vector\u003cint\u003e \u0026nums, int l, int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(nums, l, mid), merge_sort(nums, mid + 1, r); int i = l, j = mid + 1, k = 0; // i的边界赋值需要注意！！不是0，是l while (i \u003c= mid \u0026\u0026 j \u003c= r) { if (nums[i] \u003c= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } while(i \u003c= mid) tmp[k++] = nums[i++]; while(j \u003c= r) tmp[k++] = nums[j++]; for (int i = l, j = 0; i \u003c= r; ++i, ++j) nums[i] = tmp[j]; } vector\u003cint\u003e sortArray(vector\u003cint\u003e\u0026 nums) { tmp.resize(nums.size()); merge_sort(nums, 0, nums.size() - 1); return nums; } }; ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:2:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":["算法"],"content":"3. 差分 - AcWing题库 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5+10; int q[N], cnt[N]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e q[i]; for (int i = 0; i \u003c m; i++) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; cnt[l] += c; // 注意是 += 赋值 cnt[r + 1] -= c; } int curr = 0; for (int i = 1; i \u003c= n; i ++) { curr += cnt[i]; q[i] += curr; } for (int i = 1; i \u003c= n; i ++) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:3:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":["算法"],"content":"4. 无重复字符的最长子串 - 力扣（Leetcode） class Solution { public: int lengthOfLongestSubstring(string s) { int l = 0, r = -1, ret = 0; map\u003cchar, bool\u003e dic; while (++ r \u003c s.size()) { if(dic[s[r]]) { while (++l \u003c= r) { dic[s[l - 1]] = false; if (s[l - 1] == s[r]) break; } } dic[s[r]] = true; // printf(\"r:%d, l:%d \\n\", r, l); ret = max(ret, r - l + 1); } return ret; } }; ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:4:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":["算法"],"content":"5. 招聘 - AcWing题库 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 1010; int A[M]; int main() { int n; cin \u003e\u003e n; while (n-- \u003e 0) { int num, m; cin \u003e\u003e num \u003e\u003e m; for (int i = 0; i \u003c m; i ++) cin \u003e\u003e A[i]; // 假设n个人，选A[K] 去求最后剩下的坐标为 f(n, k) // 则假设第 A[k] 个人的坐标重置为0 // 现在轮到 n - 1 个人， 选 A[k + 1] 去求最后剩下的坐标为 f(n - 1, k + 1) // 这个坐标和实际的坐标相差 A[k]， 也就是 f(n - 1, k + 1) 和 f(n, k) 相差 A[k] // -\u003e f(n, k) = （f(n - 1, k + 1) + A[k]）% n int x = 0; // 假设就剩下1个人，他的下标是0，然后开始计算剩下2个人的情况 for (int i = 2; i \u003c= num; i ++) { x = ( x + A[(num - i) % m] ) % i; } cout \u003c\u003c x \u003c\u003c endl; } return 0; } ","date":"2022-12-14","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/:5:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/acwing%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"资讯 TSUHA0/TSUHA0 /README.md ### Hi there 👋 🌱 I’m currently learning cpp, rust \u003c!-- **TSUHA0/TSUHA0** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile. Here are some ideas to get you started: - 🔭 I’m currently working on ... - 🌱 I’m currently learning ... - 👯 I’m looking to collaborate on ... - 🤔 I’m looking for help with ... - 💬 Ask me about ... - 📫 How to reach me: ... - 😄 Pronouns: ... - ⚡ Fun fact: ... --\u003e 关于我 角色： 大学生 研究生 研究生 \u0026 实习生 职业： 数通开发 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"}]