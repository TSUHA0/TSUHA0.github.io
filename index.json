[{"categories":["算法"],"content":"ACWING算法学习记录 题目 次数 知识点 状态(1-10) 785.快速排序 2 排序 1 786.第k个数 2 查找 2 912. 排序数组 - 力扣（Leetcode） 归并 2 排序 2 剑指 Offer 51. 数组中的逆序对 - 力扣（Leetcode） 归并 2 排序 1 797. 差分 - AcWing题库 1 差分 1 3. 无重复字符的最长子串 - 力扣（Leetcode） 1 双指针 1 ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:0:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"785. 快速排序 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5 + 10; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; // 边界条件，注意！！ int x = q[l + r \u003e\u003e 1], i = l - 1, j = r + 1; while (i \u003c j) { while(q[++i] \u003c x); while(q[--j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; ++i) cin \u003e\u003e q[i]; quick_sort(q, 0, n - 1); for (int i = 0; i \u003c n; ++i) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:1:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"912. 排序数组 - 力扣（Leetcode） 归并 class Solution { public: vector\u003cint\u003e tmp; void merge_sort(vector\u003cint\u003e \u0026nums, int l, int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(nums, l, mid), merge_sort(nums, mid + 1, r); int i = l, j = mid + 1, k = 0; // i的边界赋值需要注意！！不是0，是l while (i \u003c= mid \u0026\u0026 j \u003c= r) { if (nums[i] \u003c= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } while(i \u003c= mid) tmp[k++] = nums[i++]; while(j \u003c= r) tmp[k++] = nums[j++]; for (int i = l, j = 0; i \u003c= r; ++i, ++j) nums[i] = tmp[j]; } vector\u003cint\u003e sortArray(vector\u003cint\u003e\u0026 nums) { tmp.resize(nums.size()); merge_sort(nums, 0, nums.size() - 1); return nums; } }; ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:2:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"797. 差分 - AcWing题库 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5+10; int q[N], cnt[N]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e q[i]; for (int i = 0; i \u003c m; i++) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; cnt[l] += c; // 注意是 += 赋值 cnt[r + 1] -= c; } int curr = 0; for (int i = 1; i \u003c= n; i ++) { curr += cnt[i]; q[i] += curr; } for (int i = 1; i \u003c= n; i ++) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:3:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"3. 无重复字符的最长子串 - 力扣（Leetcode） class Solution { public: int lengthOfLongestSubstring(string s) { int l = 0, r = -1, ret = 0; map\u003cchar, bool\u003e dic; while (++ r \u003c s.size()) { if(dic[s[r]]) { while (++l \u003c= r) { dic[s[l - 1]] = false; if (s[l - 1] == s[r]) break; } } dic[s[r]] = true; // printf(\"r:%d, l:%d \\n\", r, l); ret = max(ret, r - l + 1); } return ret; } }; ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:4:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"小数点精度设置 #include \u003cbits/stdc++.h\u003e using namespace std; const double pai = 3.14159; int main() { double r; cin \u003e\u003e r; // 二者均可 cout \u003c\u003c \"A=\" \u003c\u003c fixed \u003c\u003c setprecision(5) \u003c\u003c pai * r * r \u003c\u003c endl; printf(\"A=%.4lf\", pai * r * r); return 0; } int main( void ) { const double value = 12.3456789; cout \u003c\u003c value \u003c\u003c endl; // 默认以6精度，所以输出为 12.3457 cout \u003c\u003c setprecision(4) \u003c\u003c value \u003c\u003c endl; // 改成4精度，所以输出为12.35 cout \u003c\u003c setprecision(8) \u003c\u003c value \u003c\u003c endl; // 改成8精度，所以输出为12.345679 cout \u003c\u003c fixed \u003c\u003c setprecision(4) \u003c\u003c value \u003c\u003c endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457 cout \u003c\u003c value \u003c\u003c endl; // fixed和setprecision的作用还在，依然显示12.3457 cout.unsetf( ios::fixed ); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35 cout \u003c\u003c value \u003c\u003c endl; cout.precision( 6 ); // 恢复成原来的样子，输出为12.3457 cout \u003c\u003c value \u003c\u003c endl; cout \u003c\u003c fixed \u003c\u003c value \u003c\u003c endl; } ","date":"2022-12-14","objectID":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/:1:0","tags":["cpp"],"title":"语法巩固","uri":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/"},{"categories":["算法"],"content":"773. 字符串插入 - AcWing题库 将 substrsubstr 插入到 strstr 中 ASCII 码最大的那个字符后面，若有多个最大则只考虑第一个。 #include \u003cbits/stdc++.h\u003e using namespace std; int main () { string s, subs; while (cin \u003e\u003e s \u003e\u003e subs) { int i = 0; for (int j = 0; j \u003c s.size(); j++) { if (s[j] \u003e s[i]) i = j; } cout \u003c\u003c s.insert(i + 1, subs) \u003c\u003c endl; } return 0; } ","date":"2022-12-14","objectID":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/:2:0","tags":["cpp"],"title":"语法巩固","uri":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/"},{"categories":null,"content":"资讯 关于我 角色： 大学生 研究生 研究生 \u0026 实习生 职业： 数通开发 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"}]