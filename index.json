[{"categories":["draft"],"content":"1. const 指针 int main() { int a = 1; const int ic = 1; int *p1 = \u0026a; int *const p2 = \u0026a; const int *const p3 = \u0026a; const int *p4 = \u0026a; // p1 = p3; // 普通指针不能指向常量, invalid conversion from ‘const int*’ to ‘int*’ // p1 = \u0026ic;// 普通指针不能指向常量 // p3 = \u0026ic; // 常量指针不能被重新赋值 // p2 = p1; // 常量指针不能被重新赋值 p1 = p2; // ok p4 = \u0026ic;// ok p4 = p1; // ok const int \u0026r = a; return 0; } ","date":"2022-12-27","objectID":"/posts/cppprimerlog/:1:0","tags":["draft"],"title":"CppPrimerLog","uri":"/posts/cppprimerlog/"},{"categories":["算法"],"content":"ACWING算法学习记录 题目 次数 知识点 状态(1-10) 785.快速排序 2 排序 1 786.第k个数 2 查找 2 912. 排序数组 - 力扣（Leetcode） 归并 2 排序 2 剑指 Offer 51. 数组中的逆序对 - 力扣（Leetcode） 归并 2 排序 1 797. 差分 - AcWing题库 1 差分 1 3. 无重复字符的最长子串 - 力扣（Leetcode） 1 双指针 1 1455. 招聘 - AcWing题库 1 约瑟夫环，DP 1 ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:0:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"1. 快速排序 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5 + 10; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; // 边界条件，注意！！ int x = q[l + r \u003e\u003e 1], i = l - 1, j = r + 1; while (i \u003c j) { while(q[++i] \u003c x); while(q[--j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; ++i) cin \u003e\u003e q[i]; quick_sort(q, 0, n - 1); for (int i = 0; i \u003c n; ++i) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:1:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"2. 排序数组 - 力扣（Leetcode） 归并 class Solution { public: vector\u003cint\u003e tmp; void merge_sort(vector\u003cint\u003e \u0026nums, int l, int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(nums, l, mid), merge_sort(nums, mid + 1, r); int i = l, j = mid + 1, k = 0; // i的边界赋值需要注意！！不是0，是l while (i \u003c= mid \u0026\u0026 j \u003c= r) { if (nums[i] \u003c= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } while(i \u003c= mid) tmp[k++] = nums[i++]; while(j \u003c= r) tmp[k++] = nums[j++]; for (int i = l, j = 0; i \u003c= r; ++i, ++j) nums[i] = tmp[j]; } vector\u003cint\u003e sortArray(vector\u003cint\u003e\u0026 nums) { tmp.resize(nums.size()); merge_sort(nums, 0, nums.size() - 1); return nums; } }; ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:2:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"3. 差分 - AcWing题库 #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5+10; int q[N], cnt[N]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e q[i]; for (int i = 0; i \u003c m; i++) { int l, r, c; cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; cnt[l] += c; // 注意是 += 赋值 cnt[r + 1] -= c; } int curr = 0; for (int i = 1; i \u003c= n; i ++) { curr += cnt[i]; q[i] += curr; } for (int i = 1; i \u003c= n; i ++) cout \u003c\u003c q[i] \u003c\u003c \" \"; return 0; } ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:3:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"4. 无重复字符的最长子串 - 力扣（Leetcode） class Solution { public: int lengthOfLongestSubstring(string s) { int l = 0, r = -1, ret = 0; map\u003cchar, bool\u003e dic; while (++ r \u003c s.size()) { if(dic[s[r]]) { while (++l \u003c= r) { dic[s[l - 1]] = false; if (s[l - 1] == s[r]) break; } } dic[s[r]] = true; // printf(\"r:%d, l:%d \\n\", r, l); ret = max(ret, r - l + 1); } return ret; } }; ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:4:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"5. 招聘 - AcWing题库 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 1010; int A[M]; int main() { int n; cin \u003e\u003e n; while (n-- \u003e 0) { int num, m; cin \u003e\u003e num \u003e\u003e m; for (int i = 0; i \u003c m; i ++) cin \u003e\u003e A[i]; // 假设n个人，选A[K] 去求最后剩下的坐标为 f(n, k) // 则假设第 A[k] 个人的坐标重置为0 // 现在轮到 n - 1 个人， 选 A[k + 1] 去求最后剩下的坐标为 f(n - 1, k + 1) // 这个坐标和实际的坐标相差 A[k]， 也就是 f(n - 1, k + 1) 和 f(n, k) 相差 A[k] // -\u003e f(n, k) = （f(n - 1, k + 1) + A[k]）% n int x = 0; // 假设就剩下1个人，他的下标是0，然后开始计算剩下2个人的情况 for (int i = 2; i \u003c= num; i ++) { x = ( x + A[(num - i) % m] ) % i; } cout \u003c\u003c x \u003c\u003c endl; } return 0; } ","date":"2022-12-14","objectID":"/posts/acwing-learn-log/:5:0","tags":["acwing"],"title":"AcWing算法学习记录","uri":"/posts/acwing-learn-log/"},{"categories":["算法"],"content":"小数点精度设置 #include \u003cbits/stdc++.h\u003e using namespace std; const double pai = 3.14159; int main() { double r; cin \u003e\u003e r; // 二者均可 cout \u003c\u003c \"A=\" \u003c\u003c fixed \u003c\u003c setprecision(5) \u003c\u003c pai * r * r \u003c\u003c endl; printf(\"A=%.4lf\", pai * r * r); return 0; } int main( void ) { const double value = 12.3456789; cout \u003c\u003c value \u003c\u003c endl; // 默认以6精度，所以输出为 12.3457 cout \u003c\u003c setprecision(4) \u003c\u003c value \u003c\u003c endl; // 改成4精度，所以输出为12.35 cout \u003c\u003c setprecision(8) \u003c\u003c value \u003c\u003c endl; // 改成8精度，所以输出为12.345679 cout \u003c\u003c fixed \u003c\u003c setprecision(4) \u003c\u003c value \u003c\u003c endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457 cout \u003c\u003c value \u003c\u003c endl; // fixed和setprecision的作用还在，依然显示12.3457 cout.unsetf( ios::fixed ); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35 cout \u003c\u003c value \u003c\u003c endl; cout.precision( 6 ); // 恢复成原来的样子，输出为12.3457 cout \u003c\u003c value \u003c\u003c endl; cout \u003c\u003c fixed \u003c\u003c value \u003c\u003c endl; } ","date":"2022-12-14","objectID":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/:1:0","tags":["cpp"],"title":"语法巩固","uri":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/"},{"categories":["算法"],"content":"773. 字符串插入 - AcWing题库 将 substrsubstr 插入到 strstr 中 ASCII 码最大的那个字符后面，若有多个最大则只考虑第一个。 #include \u003cbits/stdc++.h\u003e using namespace std; int main () { string s, subs; while (cin \u003e\u003e s \u003e\u003e subs) { int i = 0; for (int j = 0; j \u003c s.size(); j++) { if (s[j] \u003e s[i]) i = j; } cout \u003c\u003c s.insert(i + 1, subs) \u003c\u003c endl; } return 0; } ","date":"2022-12-14","objectID":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/:2:0","tags":["cpp"],"title":"语法巩固","uri":"/posts/%E8%AF%AD%E6%B3%95%E5%B7%A9%E5%9B%BA/"},{"categories":null,"content":"资讯 TSUHA0/TSUHA0 /README.md ### Hi there 👋 🌱 I’m currently learning cpp, rust \u003c!-- **TSUHA0/TSUHA0** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile. Here are some ideas to get you started: - 🔭 I’m currently working on ... - 🌱 I’m currently learning ... - 👯 I’m looking to collaborate on ... - 🤔 I’m looking for help with ... - 💬 Ask me about ... - 📫 How to reach me: ... - 😄 Pronouns: ... - ⚡ Fun fact: ... --\u003e 关于我 角色： 大学生 研究生 研究生 \u0026 实习生 职业： 数通开发 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"}]